#!/usr/bin/python


import os, gtk, glib, sys


class Background():
    VPIX = 1
    VGEOM = 2
    default_color = "#ffd2ac"
    def __init__(self):
        self.gbase = gtk.gdk.Rectangle(0, 0, 100, 100)
        self.ipix = None
        self.pix = None
        self.size_cmds = ['cover']
        self.pos_cmds = ['center']
        self.color = None
        self.gdkcolor = None
        self.gthumb = None
        self.valid = 0
        self.set_color(self.default_color)
        self.file = ""
        # screen sizes
        self.swidth = gtk.gdk.screen_width()
        self.sheight = gtk.gdk.screen_height()
        self.sratio = float(self.swidth) / float(self.sheight)

    def color_to_pixel(self):
        c = self.gdkcolor
        p = 0xFF
        p |= (c.red & 0xFF00) << (8 * 2)
        p |= (c.green & 0xFF00) << (8 * 1)
        p |= (c.blue & 0xFF00) << (8 * 0)
        return p

    def set_base(self, rect):
        self.valid = 0
        self.gbase = gtk.gdk.Rectangle(*rect)

    def get_base(self):
        return self.gbase

    def set_base_from_desktop(self):
        self.valid = 0
        self.gbase = gtk.gdk.Rectangle(0, 0, self.swidth, self.sheight)

    def set_image(self, file):
        self.valid = 0
        # XXX: check for valid pix
        try:
            self.ipix = gtk.gdk.pixbuf_new_from_file(file)
            self.gimage = gtk.gdk.Rectangle(0, 0, self.ipix.get_width(),
                                            self.ipix.get_height())
            self.file = file
        except:
            # print "Can't open file", file
            self.ipix = None
            self.file = ""

    def get_image(self):
        return self.file

    def set_color(self, color):
        self.valid = 0
        try:
            c = gtk.gdk.color_parse(color)
        except:
            color = self.default_color
            c = gtk.gdk.color_parse(color)

        self.color = color
        self.gdkcolor = c

    def get_color(self):
        return (self.color, self.gdkcolor)

    def set_size_commands(self, cmds):
        self.valid = 0
        self.size_cmds = cmds

    def get_size_commands(self):
        return self.size_cmds

    def set_pos_commands(self, cmds):
        self.valid = 0
        self.pos_cmds = cmds

    def get_pos_commands(self):
        return self.pos_cmds

    def get_pixbuf(self):
        if not (self.valid & self.VPIX):
            self.update_pixbuf()
        return self.pix

    def update_pixbuf(self):
        self.valid |= self.VPIX

        gbase = self.gbase
        self.pix = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, False, 8,
                                  gbase.width, gbase.height)
        self.pix.fill(self.color_to_pixel())

        if self.ipix:
            g = self.get_thumb_geom()
            # print "base ", gbase
            # print "thumb", g
            dipix = self.ipix.scale_simple(g.width, g.height,
                                           gtk.gdk.INTERP_HYPER)
            ng = gbase.intersect(g)
            # print " intersection", ng
            dipix.copy_area(ng.x - g.x, ng.y - g.y,
                            ng.width, ng.height, self.pix,
                            ng.x - gbase.x,
                            ng.y - gbase.y)

    def get_thumb_geom(self):
        if not (self.valid & self.VGEOM):
            self.update_thumb_geom()
        return self.gthumb

    def update_thumb_geom(self):
        self.valid |= self.VGEOM
        self.gthumb = None

        if not self.ipix:
            return

        # print "update geom"
        gbase = self.gbase
        gimg = self.gimage
        gthumb = gtk.gdk.Rectangle(*gimg)
        gthumb.x = gbase.x
        gthumb.y = gbase.x
        gthumb.width = gimg.width
        gthumb.height = gimg.height
        for c in self.size_cmds:
            if c == "fit":
                ratio1 = gbase.width / float(gimg.width)
                ratio2 = gbase.height / float(gimg.height)
                ratio = min(ratio1, ratio2)
                gthumb.width = gimg.width * ratio
                gthumb.height = gimg.height * ratio
            elif c == "cover":
                ratio1 = gbase.width / float(gimg.width)
                ratio2 = gbase.height / float(gimg.height)
                ratio = max(ratio1, ratio2)
                gthumb.width = gimg.width * ratio
                gthumb.height = gimg.height * ratio
            elif c == "scratch":
                gthumb.width = gbase.width
                gthumb.height = gbase.height
            elif c[:-1].isdigit() and (c[-1:] == "%"):
                ratio = float(c[:-1]) / 100
                gthumb.width *= ratio
                gthumb.height *= ratio
            # print "  size cmd:", c, "gthumb", gthumb

        for c in self.pos_cmds:
            if c == "center":
                gthumb.x = gbase.x + (gbase.width - gthumb.width) / 2
                gthumb.y = gbase.y + (gbase.height - gthumb.height) / 2
            # print "  pos cmd:", c, "gthumb", gthumb

        self.gthumb = gthumb



class BgArea(gtk.DrawingArea):
    def __init__(self, bg):
        gtk.DrawingArea.__init__(self)

        self.set_size_request(200, 200)
        self.connect("expose_event", self._expose)
        self.connect("size-allocate", self._size_alloc)
        self.screen_r = gtk.gdk.Rectangle(0, 0, bg.swidth, bg.sheight)
        self.da_r = gtk.gdk.Rectangle(0, 0, 10, 10)
        self.bg = bg
        self.grey_gc = None
        self.black_gc = None
        self.pix = None

    def _size_alloc(self, widget, a):
        ratio1 = float(a.width * 0.75) / self.screen_r.width
        ratio2 = float(a.height * 0.75) / self.screen_r.height
        self.ratio = min(ratio1, ratio2)
        dw = self.screen_r.width * self.ratio
        dh = self.screen_r.height * self.ratio
        dx = (a.width - dw) / 2
        dy = (a.height - dh) / 2
        self.da_r = gtk.gdk.Rectangle(int(dx), int(dy), int(dw), int(dh))
        self.bg.set_base(self.da_r)
        self.update_preview()

    def update_preview(self):
        self.pix = self.bg.get_pixbuf()
        self.queue_draw()

    def _expose(self, widget, event):
        if not self.grey_gc:
            self.grey_gc = widget.window.new_gc()
            self.grey_gc.set_rgb_fg_color(gtk.gdk.color_parse("grey"))
            self.grey_gc.line_style = gtk.gdk.LINE_SOLID

        if not self.black_gc:
            self.black_gc = widget.window.new_gc()
            self.black_gc.set_rgb_fg_color(gtk.gdk.color_parse("black"))
            self.black_gc.line_style = gtk.gdk.LINE_SOLID


        # thumbnail contour
        g = self.bg.get_thumb_geom()
        if g:
            widget.window.draw_rectangle(self.grey_gc, True, *g)
            widget.window.draw_rectangle(self.black_gc, False, *g)

        # preview content
        widget.window.draw_pixbuf(self.grey_gc, self.pix, 0, 0,
                                  self.da_r.x, self.da_r.y,
                                  self.da_r.width, self.da_r.height,
                                  gtk.gdk.RGB_DITHER_NONE, 0, 0)

        # preview contour
        widget.window.draw_rectangle(self.black_gc, False, *self.da_r)

def build_gui(bg):
    conf = []
    confe = { }

    window = gtk.Window()
    window.set_border_width(10)
    window.set_icon_name("background")
    window.connect("destroy", gtk.main_quit)

    vbox = gtk.VBox(False, 4)
    window.add(vbox)

    frame = gtk.AspectFrame(ratio = bg.sratio, obey_child = False)
    vbox.pack_start(frame, True, True, 0)
    frame.set_shadow_type(gtk.SHADOW_IN)

    bga = BgArea(bg)
    frame.add(bga)
    bga.drag_dest_set(gtk.DEST_DEFAULT_ALL,
                      [("text/uri-list", 0, 11)],
                      gtk.gdk.ACTION_COPY)
    bga.connect("drag_data_received", rx_cb, conf)
    confe["bga"] = bga
    confe["bg"] = bg

    ali = gtk.Alignment(0.5, 0.5, 0, 0)
    vbox.pack_start(ali, False, True, 0)

    vbox2 = gtk.VBox(False, 0)
    ali.add(vbox2)

    # row with scale and position settings
    hbox = gtk.HBox(False, 10)
    vbox2.pack_start(hbox, False, True, 0)

    frame = build_gui_size(conf, confe)
    hbox.pack_start(frame, True, True, 0)
    frame = build_gui_pos(conf, confe)
    hbox.pack_start(frame, False, True, 0)

    # row with effects settings
    hbox = gtk.HBox(False, 10)
    vbox2.pack_start(hbox, False, True, 0)

    frame = build_gui_effects(conf, confe)
    hbox.pack_start(frame, False, True, 0)
    frame = build_gui_image(conf, confe)
    hbox.pack_start(frame, True, True, 0)

    # row with command line
    hbox = gtk.HBox(False, 10)
    vbox2.pack_start(hbox, False, True, 0)

    frame = build_gui_cmdline(conf, confe)
    hbox.pack_start(frame, True, True, 0)

    vbox.pack_start(gtk.HSeparator(), False, True, 0)

    # row with buttons
    bb = gtk.HButtonBox()
    vbox.pack_start(bb, False, True, 0)
    bb.set_layout(gtk.BUTTONBOX_END)

    button = gtk.Button(stock = gtk.STOCK_APPLY)
    bb.add(button)
    button.connect_object("clicked", set_bg, conf)
    button = gtk.Button(stock = gtk.STOCK_CLOSE)
    bb.add(button)
    button.connect("clicked", lambda widget: gtk.main_quit())

    conf.append(confe)
    return window

def build_gui_effects(conf, confe):
    frame = gtk.Frame()
    frame.set_shadow_type(gtk.SHADOW_ETCHED_IN)
    on = gtk.CheckButton("Effects")
    confe["effects:on"] = on
    frame.set_label_widget(on)
    on.set_active(True)
    on.connect_object("toggled", settings_changed, conf)

    hbox = gtk.HBox(False, 5)
    frame.add(hbox)
    hbox.set_border_width(7)

    label = gtk.Label("Color")
    hbox.pack_start(label, False, False, 0)

    csel = gtk.ColorButton()
    hbox.pack_start(csel, False, False, 0)
    c, gdkc = confe["bg"].get_color()
    csel.set_color(gdkc)
    csel.connect_object("color-set", settings_changed, conf)
    confe["effects:color"] = csel

    return frame

def build_gui_image(conf, confe):
    frame = gtk.Frame()
    frame.set_shadow_type(gtk.SHADOW_ETCHED_IN)
    on = gtk.CheckButton("Image")
    confe["image:on"] = on
    frame.set_label_widget(on)
    on.set_active(True)
    on.connect_object("toggled", settings_changed, conf)

    fsel = gtk.FileChooserButton('Select a File')
    frame.add(fsel)
    confe["image:file"] = fsel
    fsel.set_filename(confe["bg"].get_image())
    # fsel.set_width_chars(10)
    # fsel.connect_object("file-set", settings_changed, conf)
    fsel.connect_object("selection-changed", settings_changed, conf)

    return frame

def build_gui_cmdline(conf, confe):
    on = gtk.Expander("Command Line")
    on.set_expanded(True)

    sw = gtk.ScrolledWindow()
    on.add(sw)
    sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
    sw.set_size_request(-1, 60)
    sw.set_shadow_type(gtk.SHADOW_IN)

    textview = gtk.TextView()
    sw.add(textview)
    textview.set_wrap_mode(gtk.WRAP_WORD)
    textbuffer = textview.get_buffer()
    confe["cmdline:text"] = textbuffer

    return on


def build_gui_pos(conf, confe):
    frame = gtk.Frame()
    frame.set_shadow_type(gtk.SHADOW_ETCHED_IN)
    on = gtk.CheckButton("Position")
    confe["pos:on"] = on
    frame.set_label_widget(on)
    on.set_active(True)
    on.connect_object("toggled", settings_changed, conf)

    hbox = gtk.HBox(False, 5)
    frame.add(hbox)
    hbox.set_border_width(7)

    label = gtk.Label("Gravity")
    hbox.pack_start(label, False, False, 0)

    liststore = gtk.ListStore(str, str)
    combobox = gtk.ComboBox(liststore)
    combobox.connect_object('changed', settings_changed, conf)
    hbox.pack_start(combobox, False, False, 0)
    confe["pos:type"] = combobox

    cell = gtk.CellRendererText()
    combobox.pack_start(cell, True)
    combobox.add_attribute(cell, 'text', 0)
    liststore.append(['Center', 'center'])
    combobox.set_active(0)

    return frame

def build_gui_size(conf, confe):
    frame = gtk.Frame()
    frame.set_shadow_type(gtk.SHADOW_ETCHED_IN)
    on = gtk.CheckButton("Scale")
    confe["scale:on"] = on
    frame.set_label_widget(on)
    on.set_active(True)
    on.connect_object("toggled", settings_changed, conf)

    hbox = gtk.HBox(False, 5)
    frame.add(hbox)
    hbox.set_border_width(7)

    label = gtk.Label("Type")
    hbox.pack_start(label, False, False, 0)

    liststore = gtk.ListStore(str, str)
    combobox = gtk.ComboBox(liststore)
    combobox.connect_object('changed', settings_changed, conf)
    hbox.pack_start(combobox, False, False, 0)
    confe["scale:type"] = combobox

    cell = gtk.CellRendererText()
    combobox.pack_start(cell, True)
    combobox.add_attribute(cell, 'text', 0)
    liststore.append(['Fit', 'fit'])
    liststore.append(['Cover', 'cover'])
    liststore.append(['Scratch', 'scratch'])
    combobox.set_active(0)

    label = gtk.Label(" ")
    hbox.pack_start(label, False, False, 7)

    label = gtk.Label("Ratio")
    hbox.pack_start(label, False, False, 0)

    adj1 = gtk.Adjustment(100.0, 1.0, 9999, 1.0, 5.0, 0.0)
    confe["scale:ratio"] = adj1
    spinner = gtk.SpinButton(adj1, 0, 0)
    hbox.pack_start(spinner, False, True, 0)
    adj1.connect_object("value_changed", settings_changed, conf)

    label = gtk.Label("%")
    hbox.pack_start(label, False, False, 0)

    return frame

def rx_cb(widget, drag_context, x, y, selection, info, time, conf):
    print "rx"
    confe = conf[0]
    uri = selection.data.split()[0]
    # print confe["image:file"].set_uri(uri)
    print confe["image:file"].select_uri(uri)


def settings_changed(conf, *rest):
    if not len(conf):
        return
    confe = conf[0]
    bg = confe["bg"]
    bga = confe["bga"]
    # print confe

    size_cmd = []
    if confe["scale:on"].get_active():
        # scale:type
        combobox = confe["scale:type"]
        model = combobox.get_model()
        index = combobox.get_active()
        if index > -1:
            size_cmd.append(model[index][1])

        # scale:ratio
        adj = confe["scale:ratio"]
        size_cmd.append(str(int(adj.get_value())) + "%")
    bg.set_size_commands(size_cmd)
    # print size_cmd

    pos_cmd = []
    if confe["pos:on"].get_active():
        # scale:type
        combobox = confe["pos:type"]
        model = combobox.get_model()
        index = combobox.get_active()
        if index > -1:
            pos_cmd.append(model[index][1])

    bg.set_pos_commands(pos_cmd)
    # print pos_cmd

    color = ""
    if confe["effects:on"].get_active():
        c = confe["effects:color"].get_color()
        color = gtk.color_selection_palette_to_string([c])
    bg.set_color(color)
    # print color

    image = ""
    if confe["image:on"].get_active():
        image = confe["image:file"].get_filename()
        if image is None:
            image = ""
    bg.set_image(image)

    text = sys.argv[0]
    text += " --scale=" + ','.join(size_cmd)
    text += " --pos=" + ','.join(pos_cmd)
    text += " --color=" + color
    text += " " + image
    textbuffer = confe["cmdline:text"]
    textbuffer.set_text(text)

    bga.update_preview()

def set_bg(conf):
    if not len(conf):
        return
    confe = conf[0]
    bg = confe["bg"]
    base = bg.get_base()
    bg.set_base_from_desktop()
    # print bg.get_base()
    pix = bg.get_pixbuf()
    bg.set_base(base)

    root = gtk.gdk.get_default_root_window()
    pmap = gtk.gdk.Pixmap(root, pix.get_width(), pix.get_height())
    pmap.draw_pixbuf(root.new_gc(), pix, 0, 0, 0, 0)

    opmap_id = root.property_get("ESETROOT_PMAP_ID")[2][0]
    root.property_change("_XROOTPMAP_ID",
                         "PIXMAP", 32, gtk.gdk.PROP_MODE_REPLACE,
                         [pmap.xid])
    root.property_change("ESETROOT_PMAP_ID",
                         "PIXMAP", 32, gtk.gdk.PROP_MODE_REPLACE,
                         [pmap.xid])
    root.set_back_pixmap(pmap, False)
    root.clear()
    # XXX: delete old pixmap
    gtk.gdk.display_get_default().flush()

    # print "root %x, old pmap %x, new pmap %x" % (root.xid, opmap_id, pmap.xid)
    save_commands(bg)

import argparse

def arg_parse(argv):
    # command line args
    p = argparse.ArgumentParser()

    p.add_argument('-s', '--scale', dest = 'scale', nargs = 1,
                   help = "Scale commands sep by comma: fit, cover, scratch"
                   + "and NUM%")
    p.add_argument('-p', '--pos', dest = 'pos', nargs = 1,
                   # default = "",
                   help = "Position commands: center")
    p.add_argument('-c', '--color', dest = 'color', nargs = 1,
                   help = "Background color (name or #rrggbb)")
    p.add_argument('-g', '--gui', action = 'store_true', default = False,
               help = 'Open image settings GUI')
    p.add_argument('image', nargs='?', help = 'image')

    return p.parse_args(argv)

def save_commands(bg):
    os.chdir(os.getenv("HOME"))
    try:
        os.mkdir(".config")
    except:
        pass

    try:
        f = open(".config/bgpreview", "w")
    except:
        return

    str = "bgpreview" + \
        " --scale=" + ','.join(bg.get_size_commands()) + \
        " --pos=" + ','.join(bg.get_pos_commands()) + \
        " --color=" + bg.get_color()[0]
    if bg.get_image() != "":
        str += " \\\n" + bg.get_image()
    str += "\n"

    # print str
    f.write(str)
    f.close()

def main():
    cdir = os.getenv("HOME") + "/.config/"
    cfile = "/bgpreview"
    argv = sys.argv
    if len(argv) == 1:
        try:
            f = open(cdir + cfile, "r")
            str = f.readline().strip()
            argv = str[:-1].split()
            if str[-1:] == "\\":
                del argv[-1]
                str = f.readline().strip()
                argv += [ '-g', str ]
        except:
            print "can't open config file"
            pass

    # print argv
    args = arg_parse(argv[1:])
    # print args

    bg = Background()
    if not args.image is None:
        bg.set_image(args.image)
    if args.scale:
        bg.set_size_commands(args.scale[0].split(','))
    if args.pos:
         bg.set_pos_commands(args.pos[0].split(','))
    if args.color:
         bg.set_color(args.color[0])
    bg.update_thumb_geom()

    if args.gui or len(sys.argv) == 1:
        window = build_gui(bg)
        window.show_all()
        gtk.main()
    else:
        set_bg([{ 'bg' : bg }])

main()
